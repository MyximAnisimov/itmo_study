Архитекутра компьютера - Лабораторная №3
======
Выполнил
---
Анисимов Максим Дмитриевич P3233

Вариант (упрощённый)
---
> Базовый вариант: alg | risc | neum | hw | instr | binary | stream | mem | pstr | prob1 | cache
Вариант после упрощения: asm | risc | neum | hw | instr | struct | stream | mem | pstr | prob1 | cache

Синтаксис языка
---
Синтаксис в расширенной БНФ
* ```[...]``` - вхождение 0 или 1 раз
* ```{...}``` - вхождение 0 или несколько раз
* ```{...}```- - вхождение 1 или несколько раз

### Форма Бэкуса-Наура
```
program ::= { program_line }-

program_line ::= code_line [ comment ]

code_line ::=  data_label ":" 
        | insruction 
        | data

data ::= ".word" variable

variable ::= integer
       | string
       | label_name

instruction ::= op0 
       | op1 register 
       | op2 register "," register
       | op3 address
       | op4 register, address
       | op4 address, register

address ::= label_name | "(" label_name ")"

label_name ::= <any of "a-z A-Z"> { <any of "a-z A-Z 0-9 _ "> }

register ::= "r" <any of "0-3">

op0 ::= "nop" 
      | "hlt" 

op1 ::= "inc" 
      | "dec"

op2 ::= "add" 
      | "sub"
      | "mod"
      | "test"
      
op3 ::= "jg" 
      | "jng"
      | "jz" 
      | "jnz" 
      | "jmp"

op4 ::= "mov"

integer :: = [ "-" ] { <any of "0-9"> }-

positive_integer :: = { <any of "0-9"> }-

string ::= "\'" { <any of "a-z A-Z">}- "\'"

comment ::= ";" { <any symbol except "\n"> }
```
### Команды
#### op0 (Безадресные команды)
* ```nop``` - нет операции
* ```hlt``` - остановка работы программы
#### op1 (Адресные команды)
* ```inc { register }``` - операция инкрементации значения в регистре
* ```dec { register }``` - операция декрментации значения в регистре
#### op2 (Адресные команды)
Результаты сохраняются в первом регистре команды
* ```add { register register }``` - сложение первого и второго регистра
* ```sub { register register }``` - вычитание первого и второго регистра
* ```mod { register register }``` - нахождение остатка деления первого регистра на второй
* ```test {register register}``` - логическое умножение двух регистров
#### op3 (Команды ветвления)
* ```jg { label_name }``` - переход по адресу label_name, если флаг N = 0 (Результат вычислений положительный)
* ```jng { label_name }``` - переход по адресу label_name, если флаг N != 0 (Результат вычислений отрицательный)
* ```jz {label_name }``` - переход по адресу label_name если флаг Z = 0 (Результат вычислений равен 0)
* ```jnz { label_name }``` - переход на указанную метку если Z != 0 (Результат вычислений не равен 0)
* ```jmp { label_name }``` - безусловный переход по адресу
#### op4 (Адресная команда)
* ```mov { register, address }``` - загрузить значение из address в register
* ```mov { address, register }``` - загрузить значение из register в address

### Семантика
* Глобальная видимость данных
* Есть поддержка литералов (Чисельных и строковых)
    + Пример объявления литерала: `.word 10000` или `.word 'Hello world!'
* Строки хранятся в виде Паскаль-подобных
* Метка `_start` является началом программы
* Текст, написанный после `;` является комментарием
* Выполнение кода происходит последовательно. Возможен переход на другие участки кода при помощи команд ветвления. Поддержка подпрограмм отсутствует

Организация памяти
---
* Архитектура фон-Неймана
* Машинное слово - не определено
### Схема памяти
```
          registers    
+----------------------------+
| r0: general register       |
| r1: general register       |
| r2: general register       |
| r3: general register       |
| ip: counter                |
| ar: address register       |
| dr: data register          |
| ps: program state register |
+----------------------------+

            memory
+----------------------------+
| 00:  start address (n)     |
| 01:  input port            |
| 02:  output str port       |
| 03:  output int port       |   
| 04:       ...
|      variables space       |
|           ...              |
| n:   program start         |
|           ...              |
+----------------------------+
```
* В ячейке `00` лежит адрес начала программы
* В ячейках `01`, `02`, `03` хранятся порты ввода-вывода
* В ячейках с `03` по `n` хранятся переменные, используемые в программе:
    + Целочисельные
    + Строковые
### Адресация памяти
- Асболютная адресация
- Косвенная адресация

Система команд
---
### Особенности процессора
* Машинное слово - не определено. Инструкции хранятся как высокоуровневая структура
* Пользователь может оперировать только четырьмя регистрами общего назначения `r0 - r3`. Служебные регистры используются самим процессором
* Ввод-вывод осуществляется асинхронно. В качестве устройства для ввода-вывода используются 3 ячейки общей памяти: одна для ввода, две другие для вывода целочисельных и строковых данных
* Поток управления:
    + Поддерживаются условные и безусловные переходы. Если условие перехода не выполняется, то осуществляется инкрементация регистра `IP`
### Кодирование инструкций
* Машинный код сериализуется в список JSON
* Один элемент списка - однак инструкция
Пример:
```
[
   {
     "index": 0,
     "opcode": "add",
     "arg_1": "r0",
     "is_indirect_1": false,
     "arg_2": "r1",
     "is_indirect_2": false
   }
]
```
где:
* `index` - адрес памяти
* `opcode` - код операции
* `arg_1` - первый аргумент
* `is_indirect_1` - косвенная ли адресация для arg_1
* `arg_2` - второй аргумент
* `is_indirect_2` - косвенная ли адресация для arg_2
  Типы данных в модуле isa, где:
* `Opcode` - перечсление кодов операции

Транслятор
---
Интерфейс командной строки: ``` python translator.py <source_file> <target_file>```
Реализовано в модуле: translator.py
Этапы трансляции (функция ```translate```):
1. Очистка исходного текста от лишних пробелов, комментариев и пустых строк (функция ```clean_source```)
2. Выделение переменных программы (функция ```translate_section_data```)
3. Выделение меток (функция ```translate_section_text_stage_1```)
4. Выделение команд (функция ```translate_section_text_stage_2```)
5. Трансляция переменных в бинарный код (функция ```translate_variables```)
6. Трансляция команд в бинарный код (функция ```translate_commands```)
7. Объединение результатов двух последних шагов и формирование машинного кода

Правила трансляции в машинный код:
- Одна переменная - одна строка
- Одна команда - одна строка
- Ошибку компиляции вызовет:
    - Любая незивестная команда
    - Использование меток или целых чисел во всех командах, кроме команды ```mov```
    - Незивестная метка
    - Повторное задание метки
    - Некорректный тип данных в слове ```.word```
    - Двойная косвенная адресация в командах с двумя переменными
    - Косвенная адресация с использованием регистров

Модель процессора
---
Интерфейс командной строки: ```machine.py <machine_code_file> <input_file>```

Реализовано в модуле: machine
### DataPath
![Image alt](https://github.com/MyximAnisimov/itmo_study/blob/main/2_year/Computer_Architecture/Labwork3/DataPath1.png)

Реализован в классе ```DataPath```

```memory``` - однопортовая память, чтение и запись выполняются поочерёдно

Регистры (соответствуют регистрам на схеме):

+ ```Registers``` - регистры общего назначения
    +```r0```
    +```r1```
    +```r2```
    +```r3```

+ Служебные регистры
    +```pc``` - счетчик команд
    +```ps``` - регистр состояния
    +```ar``` - адресный регистр
    +```ir``` - регистр команды
    +```dr``` - регистр данных, нужен при косвенной адресации

Объекты:

+```input_buffer``` - входной буфер данных
    +адрес в памяти = 1
+```output_symbol_buffer``` - выходной буфер для символов
    +адрес в памяти = 2
+```output_numeric_buffer``` - выходной буфер для чисел
    +адрес в памяти = 3
+```alu``` - арифметико-логическое устройство
    +мультиплексоры реализованы в виде Enum (Selectors) в модуле isa
    +операции алу реализованы в виде Enum (ALUOpcode) в модуле isa
Сигналы (реализованы в виде методов класса ```DataPath```):

+```signal_fill_memory``` - заполнить память программой
+```signal_latch_<reg>``` - защелкнуть регистр ```<reg>```
+```signal_write``` - записать в память по адресу в ```ar```
+```signal_execute_operation_on_alu``` - записать в память по адресу в ```ar```

### Control Unit
![Image alt](https://github.com/MyximAnisimov/itmo_study/blob/main/2_year/Computer_Architecture/Labwork3/ControlUnit.png)

Реализован в классе ```ControlUnit```

* Hardwired (реализовано полностью на Python)
* Метод decode_and_execute_instruction моделирует выполнение полного цикла инструкции

Особенности работы модели:

* Цикл симуляции осуществляется в функции ```simulation```
* Шаг моделирования соответствует одной инструкции с выводом состояния в журнал (каждая запись в журнале соответсвует состоянию процессора после выполнения инструкции)
* Для журнала состояний процессора используется стандартный модуль ```logging```

