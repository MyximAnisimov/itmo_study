1. Многопоточность Джава. Класс Thread. Интерфейс Runnable. Модификатор synchronized

Многопоточность - одновременное выполнение двух и более потоков для макисмального
использования центрального процессора.Каждый поток работает парраллельно.

Процесс - программа или команда, выполняемая на компьютере

Поток - наименьшее составляющее процесса, набор кода и данных, кратчайшая 
последовательность инструкций, необходимая для выполнения вычислительной задачи.

Преимущества многопоточки: опитмизацяи работы одного процессора, оптимальное 
использование нескольких ЦП, улучшенная скорость ответа на запрос и распределение
ресурсов ЦП

Состояния потоков: 

new - при создании экземпляра класса Thread, поток нходится в состоянии new. 
Пока не работает

running - поток запущен и процессор начинает его выполнение. состояние может 
измениться на Runnable, Dead, Blocked

suspended - поток приостанавливает работу, затем может возобновить работу

blocked - поток ожидает высвобождение ресурсов или завершение операции ввода-выводв

terminated - поток немедленно завершает работу, его нельзя возобновить

dead - после завершения выполнения поток завершает жизненный цкил

Способы запуска потоков:
 - Предоставить реализацию объекта Runnable. Интерфейс определяет метод run(), ко
торый должен содержать код. Данный метод более гибкий, так как этот объект
превращает отличный от Thread класса в подклас и используется для высокоуровневых
 API управления потомками

- Использовать подкласс Thread, так как Thread сам реализует интерфейс Runnable.
Подходит для более простых задач

Потоки-демоны - низкоприоритетные потоки, работающие в фоновом режиме для 
сборки мусора и очистки памяти, не влияют на закрытие JVM

Заврешение потоков происходит по методу stop()

Модификатор synchronized:

Предназначен для поочердёдного доступа потоков к общим данным. Необходимо для того
чтобы не возникло утечки данных или одновременного изменения данных несколькими
потоками одновременно. synchronized позволяет "войти в монитор объекта", где монитор
- спец объект, который следит за состоянием метода и объекта.
Минусы: эффект узкого горлышка

2. Методы wait(), notify() класса Object, интерфейсы Lock и COndition
Методы wait(), notify() преднзначены для общения "потоков" друг с другом. 

wait() - освобождает монитор и переводит вызывающий поток в состояние ожидания до
тех пор пока другой поток не вызовет метод notify()

notify() - продолжает работу потока, у которого ранее был вызван метод wait()

notifyAll() - возобновляет работу всех потоков, которых ранее был вызван метод
wait()

Все эти методы вызываются тольок из синхронизированного контекста

Интерфейс Lock - абстракция, допускающая выполнение блокировок, которые реализу
ются как классы Java. Преимущество: более гибкая работа
с параллельными потоками в сравнении с synchronized, сущесвтеное расширение 
возможности блокировок (Добавление новых методов для работы с блокировками)
Примеры классов: ReetrantLock, ReetrantReadWriteLock.ReadLock (.WriteLock)

Интерфейс Condition - интерфейс, который позволяет заменить методы монитора/мьютек
са (wait, notify, notifyAll) объектом, управляющим ожиданием события. Создаются
условия в блокировках
методы: await, signal, signalAll
пример: signal - сигнализирует, что поток, у которого бы вызвн метод await, может 
продолжить работу

3. Классы-синхронизаторы из пакета java.util.concurrent
Классы-синхронизаторы предназначены для синхронизации потоков по определённому
алгоритму. 

Примеры:
Семафор - ограничивает доступ к неокоторому общему ресурсу. Есть счётчик, когда в
блок кода заходит поток, счётчик уменьшается. если счётчик = 0, то потоки блокирую
тся

Замок с обратным отчсчётом - приводит в ожидание потоки до тех пор, пока не выпо
лнится ряд определённых условий. В конструкторе в качесвте параметра передаётся
количество операций, что должны быть выполнены

Барьер - ждёт пока прибудет нужное кол-во потоков, после чего "ломается"

Обменник - нужен, если в каком-то участке кода потоки должны обменяться инфой

Фазер - является более гибкой вариацией барьера

4. Модификатор volatile. Атомарные типы данных и операции
Атомарные типы данных необходимы для того, чтобы не выполнять блокировку там, где
это не нужно (пессимистичная блокировка), так как блокировка сама по себе
является очень ресурсоёмким процесс
ом, а также замедляет работу программы, так как другие потоки не могут работать
с заблокированными данными. Атомарные типы данных потоки могут менять одновременно
и если один поток поменял значение атомарных данных, то другие потоки будут работать
с новыми значениями (оптимистчиная блокировка)

Примеры: AtomicBoolean, AtomicInteger, AtomicLong, AtomicReference, AtomicIntegerArray,
AtomicLongArray, AtomicReferenceArray

5. Коллекции из пакета java.util.concurrent
Данные коллекции предназначены для работы с множеством потоков и одновременным
чтением и внесением изменений. Обычные коллекции недопустимы для одновременного
чтения и изменения данных. Все наследники concurrent collections являются
потокобезопасными. Все операии по изменению коллекции приводят к созданию новой 
копии внутреннего массива
Примеры: CopyOnWriteArrayList (Потокобезопасный ArrayList), ConcurrentHashMap
(группа HashMap), CopyOnWriteArraySet (сделан на основе CopyOnWriteArrayList с
реализацией интерфейса Set), ConcurrentSkipLastMap (Аналог TreeMap),
ConcurrentSkipListSet (Выполнен на основе ConcurrentSkipListMap с реализацией 
интерфейса Set)

6. Интерфейсы Executor, ExecutorService, Callable, Future
Фреймворк Executor предназначен для того, чтобы отделить создание потоков от 
остального приложения, чтобы не нагружать само приложение объектами класса 
Thread. Призван оптимизировать работу с несколькими потоками одновременно.
Фреймворк Executor имеет три интерфейса: Executor, ExecutorService, SheduleExecu
torService
Интерфейс Executor содержит метод execute() для запуска задачи, заданнй объектом 
Runnable
Интерфейс ExecutorService - субинтерфейс интерфейса Executor, который добавляет ещё
больше функционала для работы с жизненным циклом потоков. Включает в себя метод 
submit() (Который в качестве аргумента может принимать выполняемый Runnable или
вызываемый Callable),
который более универсален в сравнении с execute(). Если мы передаём в качестве
параметра объект класса Callable, то метод submit возвращает объект класса Future,
так задача, определяемая объектом Callable также может возвращать значение. Объект 
класса Future хранит в себе результат асинхронного вычисления

7. Пулл потоков - набор объектов Runnable и постоянно работающих потоков. Коллекция
объектов Runnable - рабочая очередь. Постоянно работающие потоки проверяют рабочий 
запрос на наличие новой работы, и если работа должна быть выполнена, то из рабоче
й очереди будет запущен объект Runnable.
Основные методы для создания пула потоков:

newSingleThreadExecutor() - выполняет по одной задаче, остальные задачи отправляю
тся в очередь

newFixedThreadPool() - Позволяет создать пул потоков с фиксированным количеством 
потоков

newCachedThread() - создаёт пул потоков, где макс размер пула потоков - 
макс целочисельное значени в Джава. Этот метод создаёт новые потоки по запросу
и удаляет те потоки, что простаивают без работы больше минуты. Для лучшей произво
дительности лучше использовать CachedThreadPool. Для лучшего управления ресурсами
лучше использовать newFIxedThreadPool()

newScheduledThreadPool() - метод позвяолет создать пул потоков, который планирует
выполнение задач после заданной задержки или через регулярные промежутки времени

Никогда не ставьте в очередь задачи, которые в это самое время ожидают 
результатов от других задач. Это может привести к тупику.Пул потоков после
окончания работы должен быть явно завершен путем вызова метода shutdown(). 
Если этого не сделать, программа будет продолжать работать без конца. 
Если вы отправите исполнителю другую задачу после завершения работы, она выдаст 
исключение RejectedExecutionException.
Будьте осторожны, применяя потоки для длительных операций. Это может привести 
к бесконечному ожиданию потока и в конечном итоге — к утечке ресурсов

8. JDBC. Порядок взаимодействия с базой данных. Класс DriverManager. 
Интерфейс Connection
JDBC - соединение с базами данных джава, предназначен для взаимодействия прило
жения с СУБД. В основном построена на драйверах. Для соединения с СУБД важно
иметь три параметра: логин и пароль пользователя баз данных и URL базы данных
ДЛя подключения к БД необходимо создавать объект класса connection и в качестве 
значения передавать результат выполнения метода getConnection() (При чём
в этот метод метод передаются наши параметры user, password, url) класса Driver
Manager. Далее у объекта Connection мы вызываем метод createStatement(), который
создаёт запрос - объект типа Statement. Исполнение запроса производится при помощи
метода executeQuery(). executeQuery() возвращает результат - объект типа ResultSet
Результат представялет из себя таблицу и реализует шаблон итератор - перебирает
строчки с помощью метода next(). После завершения работы необходимо закрыть все 
объекты
DriverManager - содержит список драйверов
Connection - абстракция соединения с базой данных


