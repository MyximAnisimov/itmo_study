1. Сетевое взаимодействие - клиент-серверная архитектура, основные протоколы,
их сходства и отличия
TCP/IP - совокупность протоколов передачи информации. Особое обозначение всей сети
которая функционируте на основе ТСР и IP

ТСР - вид протокола транспортного уровня, который является связующим звеном для установки качества 
соединения между 2 устройствами, передачи данных и верификации их получения

IP - протокол, в функции которого входит корректность доставки сообщений по 
выбранному адресу. Информация делится на пакеты

МАС - вид протокола, на основании которого происходит процесс верификации сетевых 
устройств. Все устройства, подключённые к Интернету, содержат свой MAC адрес

UDP - протокол транспортного уровня, управляющий передачей данных, но данные не проходят верификацию
при получении, но функционирует быстрее TCP

HTTP - протокол передачи информации, в возможности которого входит процесс 
запрашивания необходимых данных у виртуально удалённой системы

2. TCP. Класс Socket и ServerSocket
Сокет - поток входных и выходных данных, "мост" между клиентом и сервером
Класс Socket представляет собой сокет, а ServerSocket - механизм серверной програм
мы для прослушивания клиентом и установки соединения с ними.
-Серв создаёт объект серверСокета
-Серв вызывает метод accept у серверСокета. Метод ждёт пока клиент подключиться к
серваку по укзанному порту
-По завершению ожидания серва клиент создаёт экземпляр класс сокет
-конструктор класса сокет осуществляет попытку подключить клиента к указанному серверу
В tcp данные могут передаваться по двум потокам одновременно

3. UDP. Класс DatagramSocket и DatagramPacket.
DatagramSocket - класс, который предназначен для обмена данными между клиентом 
и сервером. Создаёт клиентский сокет.
DatagramPacket - класс, который представляет собой пакет датаграмм.
Реализовывает доставку пакетов без подключения. Каждое сообщение направляется с 
одной машины на другую на основке информации, содержащиеся в этом пакете.
Пакеты могут поступать в случайном порядке, доставка пакетов не гарантируется

4. Отличия блокирующего и неблокирующего ввода-вывода, их преимущества и недостатки. 
Работа с сетевыми каналами.
Блокирующий ввод-вывод (IO) является потокоориентированным и подразумевает чтение
/запись из потока/ в поток одного или нескольких байт в секунду поочерёдно. Пе
редаваемая информация нигде не кэшируется, поэтому невозможно двигаться по потоку 
вперёд и назад. Также если в потоке выполнения вызывается read или write метод
любого класса из пакета java.io.* происходит блокировка до тех пор пока данные не
будут считаны или записаны
Неблокирующий ввод-вывод (NIO) является буфер-ориентированным и позволяет 
считанные данные из канала и получать то, что досутпно на данный момент
Каналы - логические порталы, через которые идёт ввод-вывод данных. То есть, 
Java.NIO использует один поток для выполнения нескольких задач
В НИО используются селекторы для обслуживания каналов

5. Классы SocketChannel и DatagramChannel
SocketChannel можно читать и записывать в виде файла. В отличие от 
блочно-ориентированного чтения и записи файлов, сокеты ориентированы на потоки,
 и только чтение отключения сокета вернет

DatagramChannel - это канал, который может отправлять и получать пакеты UDP. 
Поскольку UDP является сетевым протоколом без установления соединения, его 
нельзя читать и записывать, как другие каналы. Он отправляет и принимает пакеты 
данных.


6. Передача данных по сети. Сериализация объектов.
Сериализация объектов необходима для превращения данных в поток байтов, которые
потом можно отправлять между клиентом и сервером
Во время сериализации объектов сохраняется его граы объектов, то есть все связанные
с этим объектом объекты других классов также будут сериализованы

7. Java Stream API - интерфейс, который обеспечивает более быстрый процесс обработки
данных. 
Конвейерных методов в стриме может быть много. Терминальный метод — только один.
После его выполнения стрим завершается
Промежуточные операции следует воспринимать как «отложенные», т.е. они не 
меняют сами данные, а только задают правила их изменения. Промежуточные
данные возвращают трансформированный поток
А терминальные как раз инициируют всю цепочку преобразований и возвращают 
модифицированные данные.
Конвейерные методы: filter, sorted, limit, skip
Терминальные: findFirst, findAny, collect, count


до перенумерации	x1	x2	x3	x4	x5	x6	x7	x8	x9	x10	x11	x12
после перенумерации	x1	x2	x3	x4	x5	x7	x6	x10	x9	x8	x12	x11
  ψ13={u3 12,u3 9,u3 7,u4 6}
 ψ14={u3 12,u4 12,u4 11,u4 6}
 ψ15={u3 12,u4 12,u4 11,u5 11,u5 10,u5 8}
 ψ16={u3 12,u3 5,u5 11,u5 10,u5 8}

 ψ3={u2 11,u2 9,u1 11,u2 7,u3 5,u3 7}
 ψ15={u3 12,u4 12,u4 11,u5 11,u5 10,u5 8}

